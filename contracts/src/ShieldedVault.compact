pragma language_version 0.18.0;

import CompactStandardLibrary;

export ledger balance_commitments: HistoricMerkleTree<10, Bytes<32>>;
export ledger spent_nullifiers: Set<Bytes<32>>;

witness findAuthPath(commitment: Bytes<32>): MerkleTreePath<10, Bytes<32>>;
witness secretKey(): Bytes<32>;
witness value(): Uint<64>;

export circuit deposit(commitment: Bytes<32>): [] {
  balance_commitments.insert(disclose(commitment));
}

export circuit withdraw(): [] {
  const sk = secretKey();
  const authPath = disclose(findAuthPath(publicKey(sk)));
  assert(balance_commitments.checkRoot(merkleTreePathRoot<10, Bytes<32>>(authPath)), "not authorized");
  const nul = disclose(nullifier(sk));
  assert(!spent_nullifiers.member(nul), "already withdrawn");
  spent_nullifiers.insert(nul);
  // Actual transfer logic would be handled off-chain or in another contract
}

circuit publicKey(sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<2, Bytes<32>>>([pad(32, "commitment-domain"), sk]);
}

circuit nullifier(sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<2, Bytes<32>>>([pad(32, "nullifier-domain"), sk]);
}