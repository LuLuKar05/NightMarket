pragma language_version 0.18.0;

import CompactStandardLibrary;

enum Outcome { UNDECIDED, YES, NO }

struct ComplianceRules {
  allowed_jurisdictions: Vector<10, Opaque<"string">>;
  min_kyc_level: Uint<8>;
  max_position_size: Uint<64>;
  requires_kyc: Boolean;
}

struct Market {
  market_id: Uint<64>;
  question: Opaque<"string">;
  description: Opaque<"string">;
  end_time: Uint<64>;
  resolution_time: Uint<64>;
  market_creator: Bytes<32>;
  is_resolved: Boolean;
  outcome: Outcome;
  total_liquidity: Uint<64>;
  yes_position_count: Uint<64>;
  no_position_count: Uint<64>;
  compliance_rules: ComplianceRules;
}

export ledger market_count: Counter;
export ledger markets: Vector<100, Market>;
export ledger factory_owner: Bytes<32>;

witness sender(): Bytes<32>;
witness kyc_proof(): Opaque<"kyc_proof">;

export circuit create_market(
  question: Opaque<"string">,
  description: Opaque<"string">,
  end_time: Uint<64>,
  resolution_time: Uint<64>,
  compliance_rules: ComplianceRules
): Uint<64> {
  assert(verify_kyc(kyc_proof()), "Invalid KYC proof");
  market_count.increment(1);
  let market_id = market_count as Uint<64>;
  let new_market: Market = Market{
    market_id,
    question,
    description,
    end_time,
    resolution_time,
    sender(),
    false,
    Outcome.UNDECIDED,
    0,
    0,
    0,
    compliance_rules
  };
  markets[market_id - 1] = new_market;
  return market_id;
}

export circuit get_market_details(market_id: Uint<64>): Market {
  assert(market_id > 0 && market_id <= market_count as Uint<64>, "Market not found");
  return markets[market_id - 1];
}

circuit verify_kyc(proof: Opaque<"kyc_proof">): Boolean {
  // Placeholder for actual ZK-KYC verification logic
  return true;
}