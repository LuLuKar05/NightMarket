pragma language_version 0.18.0;

import CompactStandardLibrary;

enum Outcome { UNDECIDED, YES, NO }

struct ComplianceRules {
  allowed_jurisdictions: Vector<10, Opaque<"string">>;
  min_kyc_level: Uint<8>;
  max_position_size: Uint<64>;
  requires_kyc: Boolean;
}

struct Market {
  market_id: Uint<64>;
  question: Opaque<"string">;
  description: Opaque<"string">;
  end_time: Uint<64>;
  resolution_time: Uint<64>;
  market_creator: Bytes<32>;
  is_resolved: Boolean;
  outcome: Outcome;
  total_liquidity: Uint<64>;
  yes_position_count: Uint<64>;
  no_position_count: Uint<64>;
  compliance_rules: ComplianceRules;
}

// Public ledger state
export ledger market_count: Counter;
export ledger markets: Map<Uint<64>, Market>;
export ledger factory_owner: Bytes<32>;

// Private sender identity (supplied by the dApp)
witness sender(): Bytes<32>;

// Typed KYC proof witnesses (all private by default)
witness R(): Field;
witness s(): Field;
witness c(): Field;
witness leaf(): Field;
witness path(): Vector<32, Field>;
witness ts(): Uint<64>;
witness kyc_level(): Uint<8>;

export circuit create_market(
  question: Opaque<"string">,
  description: Opaque<"string">,
  end_time: Uint<64>,
  resolution_time: Uint<64>,
  compliance_rules: ComplianceRules
): Uint<64> {
  // KYC verification stub – real logic would go inside verify_kyc
  assert(
    verify_kyc(R(), s(), c(), leaf(), path(), ts(), kyc_level()),
    "Invalid KYC proof"
  );

  // Increment market counter (Counter.increment takes Uint<16>)[[Counter ADT](https://docs.midnight.network/compact/ledger-adt)]
  market_count.increment(1);

  // Reading a Counter as an expression returns Uint<64>[[Ledger state](https://docs.midnight.network/compact/lang-ref#declaring-and-maintaining-public-state)]
  const market_id: Uint<64> = market_count;

  const new_market: Market = Market {
    market_id,
    question,
    description,
    end_time,
    resolution_time,
    sender(),
    false,
    Outcome.UNDECIDED,
    0,
    0,
    0,
    compliance_rules
  };

  // Map.insert is a ledger ADT operation[[Map ADT](https://docs.midnight.network/compact/ledger-adt#mapkey_type-value_type)]
  markets.insert(market_id, new_market);

  return market_id;
}

export circuit get_market_details(market_id: Uint<64>): Market {
  const current_count: Uint<64> = market_count;
  assert(
    market_id > 0 && market_id <= current_count,
    "Market not found"
  );

  // Map.lookup returns the stored Market[[Map ADT](https://docs.midnight.network/compact/ledger-adt#mapkey_type-value_type)]
  return markets.lookup(market_id);
}

// KYC verification stub – uses only documented language features.
// Filled with TODOs because no Schnorr / Merkle / block-time primitives
// are described in the provided docs.
circuit verify_kyc(
  R_val: Field,
  s_val: Field,
  c_val: Field,
  leaf_val: Field,
  path_val: Vector<32, Field>,
  ts_val: Uint<64>,
  kyc_level_val: Uint<8>
): Boolean {
  // Example public constants
  const MAX_AGE_SECONDS: Uint<64> = 3600;
  const MIN_KYC_LEVEL: Uint<8> = 1;

  // TODO: implement Schnorr-style proof verification
  const schnorr_ok: Boolean = true;

  // TODO: implement Merkle inclusion check against a public registry root
  const merkle_ok: Boolean = true;

  // TODO: implement a real freshness check using documented block-time APIs
  // For now, treat freshness as always OK to avoid relying on undocumented APIs.
  const fresh_ok: Boolean = true;

  // KYC level minimum check (pure comparison on witness-derived value)
  const level_ok: Boolean = kyc_level_val >= MIN_KYC_LEVEL;

  return schnorr_ok && merkle_ok && fresh_ok && level_ok;
} 